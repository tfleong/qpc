/*****************************************************************************
* Model: qhsmtst_stm32f469i-disco.qm
* File:  ./touchscreen.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::touchscreen.c} ......................................................*/
#include "qhsmtst.h"

TS_StateTypeDef TS_State = {0};
QHsmTstEvt *qe;

/*${AOs::Touchscreen} ......................................................*/
typedef struct {
/* protected: */
    QActive super;
} Touchscreen;

/* protected: */
static QState Touchscreen_initial(Touchscreen * const me, QEvt const * const e);
static QState Touchscreen_wait(Touchscreen * const me, QEvt const * const e);
static QState Touchscreen_process(Touchscreen * const me, QEvt const * const e);


static Touchscreen l_touchscreen; /* the only instance of the Touchscreen class */

/* global-scope definitions ---------------------------------------*/
QActive *const AO_Touchscreen = &l_touchscreen.super;    /* the opaque pointer */

/*${AOs::Touchscreen_ctor} .................................................*/
void Touchscreen_ctor(void) {
    Touchscreen *me = &l_touchscreen;
    QActive_ctor(&me->super, Q_STATE_CAST(&Touchscreen_initial));
}
/*${AOs::Touchscreen} ......................................................*/
/*${AOs::Touchscreen::SM} ..................................................*/
static QState Touchscreen_initial(Touchscreen * const me, QEvt const * const e) {
    /* ${AOs::Touchscreen::SM::initial} */
    (void)e;
    return Q_TRAN(&Touchscreen_wait);
}
/*${AOs::Touchscreen::SM::wait} ............................................*/
static QState Touchscreen_wait(Touchscreen * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::Touchscreen::SM::wait::TOUCH} */
        case TOUCH_SIG: {
            /* ${AOs::Touchscreen::SM::wait::TOUCH::[TS_State.touchDetected==1]} */
            if (TS_State.touchDetected == 1) {
                BSP_TS_GetState(&TS_State);
                status_ = Q_HANDLED();
            }
            /* ${AOs::Touchscreen::SM::wait::TOUCH::[else]} */
            else {
                BSP_TS_GetState(&TS_State);
                /* ${AOs::Touchscreen::SM::wait::TOUCH::[else]::[TS_State.touchDetected==1]} */
                if (TS_State.touchDetected == 1) {
                    status_ = Q_TRAN(&Touchscreen_process);
                }
                /* ${AOs::Touchscreen::SM::wait::TOUCH::[else]::[else]} */
                else {
                    status_ = Q_HANDLED();
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Touchscreen::SM::wait::process} ...................................*/
static QState Touchscreen_process(Touchscreen * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::Touchscreen::SM::wait::process} */
        case Q_ENTRY_SIG: {
            if((TS_State.touchX[0] > BUTTON_A_X_MIN) && (TS_State.touchX[0] < BUTTON_A_X_MAX) &&
            (TS_State.touchY[0] > BUTTON_A_Y_MIN) && (TS_State.touchY[0] < BUTTON_A_Y_MAX)){
                LCD_UsrLog("A: ");
                qe = Q_NEW(QHsmTstEvt, A_SIG);
                QACTIVE_POST(AO_QHsmTst, &qe->super, me);
            }
            else if((TS_State.touchX[0] > BUTTON_B_X_MIN) && (TS_State.touchX[0] < BUTTON_B_X_MAX) &&
            (TS_State.touchY[0] > BUTTON_B_Y_MIN) && (TS_State.touchY[0] < BUTTON_B_Y_MAX)){
                LCD_UsrLog("B: ");
                qe = Q_NEW(QHsmTstEvt, B_SIG);
                QACTIVE_POST(AO_QHsmTst, &qe->super, me);
            }
            else if((TS_State.touchX[0] > BUTTON_C_X_MIN) && (TS_State.touchX[0] < BUTTON_C_X_MAX) &&
            (TS_State.touchY[0] > BUTTON_C_Y_MIN) && (TS_State.touchY[0] < BUTTON_C_Y_MAX)){
                LCD_UsrLog("C: ");
                qe = Q_NEW(QHsmTstEvt, C_SIG);
                QACTIVE_POST(AO_QHsmTst, &qe->super, me);
            }
            else if((TS_State.touchX[0] > BUTTON_D_X_MIN) && (TS_State.touchX[0] < BUTTON_D_X_MAX) &&
            (TS_State.touchY[0] > BUTTON_D_Y_MIN) && (TS_State.touchY[0] < BUTTON_D_Y_MAX)){
                LCD_UsrLog("D: ");
                qe = Q_NEW(QHsmTstEvt, D_SIG);
                QACTIVE_POST(AO_QHsmTst, &qe->super, me);
            }
            else if((TS_State.touchX[0] > BUTTON_E_X_MIN) && (TS_State.touchX[0] < BUTTON_E_X_MAX) &&
            (TS_State.touchY[0] > BUTTON_E_Y_MIN) && (TS_State.touchY[0] < BUTTON_E_Y_MAX)){
                LCD_UsrLog("E: ");
                qe = Q_NEW(QHsmTstEvt, E_SIG);
                QACTIVE_POST(AO_QHsmTst, &qe->super, me);
            }
            else if((TS_State.touchX[0] > BUTTON_F_X_MIN) && (TS_State.touchX[0] < BUTTON_F_X_MAX) &&
            (TS_State.touchY[0] > BUTTON_F_Y_MIN) && (TS_State.touchY[0] < BUTTON_F_Y_MAX)){
                LCD_UsrLog("F: ");
                qe = Q_NEW(QHsmTstEvt, F_SIG);
                QACTIVE_POST(AO_QHsmTst, &qe->super, me);
            }
            else if((TS_State.touchX[0] > BUTTON_G_X_MIN) && (TS_State.touchX[0] < BUTTON_G_X_MAX) &&
            (TS_State.touchY[0] > BUTTON_G_Y_MIN) && (TS_State.touchY[0] < BUTTON_G_Y_MAX)){
                LCD_UsrLog("G: ");
                qe = Q_NEW(QHsmTstEvt, G_SIG);
                QACTIVE_POST(AO_QHsmTst, &qe->super, me);
            }
            else if((TS_State.touchX[0] > BUTTON_H_X_MIN) && (TS_State.touchX[0] < BUTTON_H_X_MAX) &&
            (TS_State.touchY[0] > BUTTON_H_Y_MIN) && (TS_State.touchY[0] < BUTTON_H_Y_MAX)){
                LCD_UsrLog("H: ");
                qe = Q_NEW(QHsmTstEvt, H_SIG);
                QACTIVE_POST(AO_QHsmTst, &qe->super, me);
            }
            else if((TS_State.touchX[0] > BUTTON_I_X_MIN) && (TS_State.touchX[0] < BUTTON_I_X_MAX) &&
            (TS_State.touchY[0] > BUTTON_I_Y_MIN) && (TS_State.touchY[0] < BUTTON_I_Y_MAX)){
                LCD_UsrLog("I: ");
                qe = Q_NEW(QHsmTstEvt, I_SIG);
                QACTIVE_POST(AO_QHsmTst, &qe->super, me);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Touchscreen_wait);
            break;
        }
    }
    return status_;
}

